#textdomain wesnoth-After_the_Storm

# Requires: base-utils.cfg, base-variables.cfg

# I have stripped the math utilities from base-utils.cfg to tidy up things a little; this should
# ease maintenance a lot, and speed up development avoiding the need to navigate through other non-related
# macros when looking for the syntax of a mathemathical formula. -- Shadow Master

# Macros which alias {VARIABLE_OP ...} by naming them after the variable operand; others
# may even use a fixed R-value

# Note: C syntax for variable assignment:
# <variable id: l_value> = <expression: r_value>;
# =>
# Translated WML syntax:
# {VARIABLE_<some operation> <L-VALUE> <R-VALUE>}
#
# All long-name macros have a C-syntax in comment above them to
# ease understanding of them

# ********************** ARITHMETIC PRIMITIVES **********************

# l_value = l_value + r_value;
#define VARIABLE_ADD VAR_ID RVALUE
    {VARIABLE_OP {VAR_ID} add {RVALUE} }
#enddef
# l_value = l_value - r_value;
#define VARIABLE_MINUS VAR_ID RVALUE
    {VARIABLE_OP {VAR_ID} sub {RVALUE} }
#enddef
# l_value = l_value * r_value;
#define VARIABLE_MULTIPLY VAR_ID RVALUE
    {VARIABLE_OP {VAR_ID} multiply {RVALUE} }
#enddef
# l_value = l_value / r_value;
#define VARIABLE_DIVIDE VAR_ID RVALUE
    {VARIABLE_OP {VAR_ID} divide {RVALUE} }
#enddef
# l_value = l_value % r_value;
#define VARIABLE_MODULO VAR_ID RVALUE
    {VARIABLE_OP {VAR_ID} modulo {RVALUE} }
#enddef

# Short aliases of primitives
#define VARIABLE_SUM VAR_ID RVALUE
    {VARIABLE_ADD {VAR_ID} {RVALUE} }
#enddef
#define VARIABLE_MIN VAR_ID RVALUE
    {VARIABLE_MINUS {VAR_ID} {RVALUE} }
#enddef
#define VARIABLE_MUL VAR_ID RVALUE
    {VARIABLE_MULTIPLY {VAR_ID} {RVALUE} }
#enddef
#define VARIABLE_DIV VAR_ID RVALUE
    {VARIABLE_DIVIDE {VAR_ID} {RVALUE} }
#enddef
#define VARIABLE_MOD VAR_ID RVALUE
    {VARIABLE_MODULO {VAR_ID} {RVALUE} }
#enddef

# ********************** ARITHMETIC DESCENDENTS **********************

# l_value = -l_value;
#define VARIABLE_NEGATE VAR_ID
    {VARIABLE_OP {VAR_ID} multiply (-1)}
#enddef
# ++l_value;
#define VARIABLE_INCREMENT VAR_ID
    {VARIABLE_OP {VAR_ID} add (1) }
#enddef
# --l_value;
#define VARIABLE_DECREMENT VAR_ID
    {VARIABLE_OP {VAR_ID} sub (1) }
#enddef

# Short aliases of descendents
#define VARIABLE_NEG VAR_ID
    {VARIABLE_NEGATE {VAR_ID} }
#enddef
#define VARIABLE_INC VAR_ID
    {VARIABLE_INCREMENT {VAR_ID} }
#enddef
#define VARIABLE_DEC VAR_ID
    {VARIABLE_DECREMENT {VAR_ID} }
#enddef

# ********************** NUMERICAL COMPARISONS **********************

# ( l_value == r_value )
#define VARIABLE_NUMERICAL_EQUALS VAR_ID RVALUE
    [variable]
        name={VAR_ID}
        numerical_equals={RVALUE}
    [/variable]
#enddef

# ( l_value != r_value )
#define VARIABLE_NUMERICAL_NOT_EQUALS VAR_ID RVALUE
    [variable]
        name={VAR_ID}
        numerical_not_equals={RVALUE}
    [/variable]
#enddef

# ( l_value < r_value )
#define VARIABLE_NUMERICAL_LESS_THAN VAR_ID RVALUE
    [variable]
        name={VAR_ID}
        less_than={RVALUE}
    [/variable]
#enddef

# ( l_value > r_value )
#define VARIABLE_NUMERICAL_GREATER_THAN VAR_ID RVALUE
    [variable]
        name={VAR_ID}
        greater_than={RVALUE}
    [/variable]
#enddef

# ( l_value <= r_value )
#define VARIABLE_NUMERICAL_LESS_THAN_OR_EQUAL VAR_ID RVALUE
    [variable]
        name={VAR_ID}
        less_than_equal_to={RVALUE}
    [/variable]
#enddef

# ( l_value >= r_value )
#define VARIABLE_NUMERICAL_GREATER_THAN_OR_EQUAL VAR_ID RVALUE
    [variable]
        name={VAR_ID}
        greater_than_equal_to={RVALUE}
    [/variable]
#enddef

# ( l_value >= left_r_value && l_value <= right_r_value )
#define VARIABLE_NUMERICAL_IN_RANGE VAR_ID LEFT RIGHT
    [variable]
        name={VAR_ID}
        greater_than_equal_to={LEFT}
    [/variable]
    [variable]
        name={VAR_ID}
        less_than_equal_to={RIGHT}
    [/variable]
#enddef

# kate: indent-mode normal; encoding utf-8; space-indent on;
