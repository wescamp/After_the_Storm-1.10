#textdomain wesnoth-After_the_Storm

# wmlindent: start ignoring

# all forest terrains (tree, mushroom)
#define VEGETATED_TERRAINS
*^F*, *^Uf, *^Ufi #enddef

#define NOTES
    _ "

Notes: "#enddef

# As its used by some abilities' descriptions in this file, we cannot move this macro to
# special-notes.cfg without running the risk of getting a blank string by the preprocessor.
#define SPECIAL_NOTES_VEGETATED_TERRAINS
    _ " Vegetated terrains are forest, great tree, and mushroom grove hexes."#enddef

#define __ABILITY_TSTRING_SYLVAN_SPARK_NAME
    _ "sylvan spark"
#enddef
#define __ABILITY_TSTRING_SYLVAN_SPARK_DESC
    _ "Sylvan Spark:
While in vegetated terrains, the unit will heal itself 5 hp per turn. If it is poisoned, it will remove the poison instead of healing."+{NOTES}+{SPECIAL_NOTES_VEGETATED_TERRAINS}
#enddef

#define __ABILITY_TSTRING_PROTECTION
    name= _ "protection"
    description= _ "Protection:
Adjacent units of level 1 or below from this side receive a +20% bonus to all resistances (up to a maximum of 50%)."
#enddef

#define __ABILITY_TSTRING_TERROR
    name= _ "terror"
    description= _ "Terror:
This unit can frighten enemy units that are next to it, making them fight worse.

Adjacent enemy units of lower level will do less damage in battle. When an enemy unit of the same or lower level is adjacent and engages in combat, its attacks do 15% less damage times the difference in their levels + 15%."
#enddef

# wmlindent: stop ignoring

#define ABILITY_ABSORB_DAMAGE
    [dummy]
        id=absorb_damage
        name= _ "absorb damage"
        description= _ "Absorb Damage:
Units with this ability will not take damage."
    [/dummy]
#enddef

# Fake ability, actually handled by scenario-specific events to avoid cheating, etc.
#define ABILITY_GLAMOUR
    [dummy]
        id=glamour
        name= _ "glamour"
        description= _ "Glamour:
Units with this ability can take on the shape of other units at will."
    [/dummy]
#enddef

#define ABILITY_SYLVAN_ESSENCE
    [heals]
        value=8
        id=sylvan_essence_healing_and_curing
        name= _ "sylvan essence"
        description= _ "Sylvan Essence:
This unit can heal and cure friendly units on adjacent hexes every turn, to a base maximum of 8 HP. In vegetated terrains, it will conceal itself from its enemies. It can also regenerate (but not unpoison) 3 HP per-turn, but only on vegetated terrains."+{NOTES}+{SPECIAL_NOTES_VEGETATED_TERRAINS}
        affect_allies=yes
        affect_self=no
        poison=cured
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
        [/affect_adjacent]
    [/heals]
    [hides]
        id=sylvan_essence_conceal
        affect_self=yes
        [filter_self]
            [filter_location]
                terrain={VEGETATED_TERRAINS}
            [/filter_location]
        [/filter_self]
    [/hides]
    [regenerate]
        value=3
        id=sylvan_essence_selfheal
        affect_self=yes
        [filter_self]
            [filter_location]
                terrain={VEGETATED_TERRAINS}
            [/filter_location]
        [/filter_self]
    [/regenerate]
#enddef

#define ABILITY_OBSCURE
    # Canned definition of the Obscures ability to be included in an
    # [abilities] clause.
    [illuminates]
        id=obscure
        value=-25
        max_value=-25
        cumulative=no
        name= _ "obscures"
        description= _ "Obscures:
This unit darkens the surrounding area, making chaotic units fight better, and lawful units fight worse.

Any units adjacent to this unit will fight as if it were dusk when it is day, and as if it were night when it is dusk."
        affect_self=yes
    [/illuminates]
#enddef

#define ABILITY_SYLVAN_SPARK
    [regenerate]
        value=5
        id=sylvan_spark
        name={__ABILITY_TSTRING_SYLVAN_SPARK_NAME}
        description={__ABILITY_TSTRING_SYLVAN_SPARK_DESC}
        name_inactive={__ABILITY_TSTRING_SYLVAN_SPARK_NAME}
        description_inactive={__ABILITY_TSTRING_SYLVAN_SPARK_DESC}
        affect_self=yes
        [filter_self]
            [filter_location]
                terrain={VEGETATED_TERRAINS}
            [/filter_location]
        [/filter_self]
        poison=cured
    [/regenerate]
#enddef

#define ABILITY_PROTECTION
    [resistance]
        id=protection
        add=20
        max_value=50
        apply_to=blade,pierce,impact,fire,cold,arcane
        {__ABILITY_TSTRING_PROTECTION}
        affect_self=no
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                level=0
                [or]
                    level=1
                [/or]
            [/filter]
        [/affect_adjacent]

        # We need this to merely put the bonus under control; not base resistances themselves
        [filter_base_value]
            less_than_equal_to=50
        [/filter_base_value]
    [/resistance]
#enddef

#define ABILITY_TERROR_LEVEL_2
    [leadership]
        id=terror
        value=-45
        cumulative=no
        {__ABILITY_TSTRING_TERROR}
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                level=0
            [/filter]
        [/affect_adjacent]
    [/leadership]
    [leadership]
        id=terror
        value=-30
        cumulative=no
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                level=1
            [/filter]
        [/affect_adjacent]
    [/leadership]
    [leadership]
        id=terror
        value=-15
        cumulative=no
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                level=2
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef

#define ABILITY_TERROR_LEVEL_3
    [leadership]
        id=terror
        value=-60
        cumulative=no
        {__ABILITY_TSTRING_TERROR}
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                level=0
            [/filter]
        [/affect_adjacent]
    [/leadership]
    [leadership]
        id=terror
        value=-45
        cumulative=no
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                level=1
            [/filter]
        [/affect_adjacent]
    [/leadership]
    [leadership]
        id=terror
        value=-30
        cumulative=no
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                level=2
            [/filter]
        [/affect_adjacent]
    [/leadership]
    [leadership]
        id=terror
        value=-15
        cumulative=no
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                level=3
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef

# wmllint: unbalanced-on
#define ABILITY_PHYSICAL_ENDURANCE
    [dummy]
        id=physical_endurance
        name= _ "physical endurance"
        description= _ "Physical Endurance:
Units with this ability instantly regenerate half of the damage dealt to them unless its type is arcane, or the damage amount would kill them otherwise (greater than or equals their remaining HP)."
    [/dummy]
    # wmlxgettext: [abilities]
[/abilities]
[event]
    id=ability_physical_endurance_attacker_hits
    name=attacker hits
    first_time_only=no
    [filter_second]
        ability=physical_endurance
    [/filter_second]
    [filter_attack]
        [not]
            type=arcane
        [/not]
    [/filter_attack]

    [fire_event]
        name=physical endurance handler
        [primary_unit]
            x,y=$x2,$y2
        [/primary_unit]
        [secondary_unit]
            x,y=$x1,$y1
        [/secondary_unit]
    [/fire_event]
[/event]
[event]
    id=ability_physical_endurance_defender_hits
    name=defender hits
    first_time_only=no
    [filter]
        ability=physical_endurance
    [/filter]
    [filter_second_attack]
        [not]
            type=arcane
        [/not]
    [/filter_second_attack]

    [fire_event]
        name=physical endurance handler
        [primary_unit]
            x,y=$x1,$y1
        [/primary_unit]
        [secondary_unit]
            x,y=$x2,$y2
        [/secondary_unit]
    [/fire_event]
[/event]
[event]
    id=ability_physical_endurance_handler
    name=physical endurance handler
    first_time_only=no

    # Primary unit: physical endurance user
    # Secondary unit: attacker/defender

    [if]
        {VARIABLE_NUMERICAL_GREATER_THAN unit.hitpoints 0}
        [then]
            {VARIABLE_OP temp_PHYSICAL_ENDURANCE_restore_hp to_variable damage_inflicted}
            {VARIABLE_OP temp_PHYSICAL_ENDURANCE_restore_hp divide      2}
            {VARIABLE_OP temp_PHYSICAL_ENDURANCE_restore_hp round       ceil}

            [heal_unit]
                [filter]
                    x,y=$x1,$y1
                [/filter]
                amount=$temp_PHYSICAL_ENDURANCE_restore_hp
            [/heal_unit]

            [floating_text]
                x,y=$x1,$y1
                text="<span color='green'>$heal_amount</span>" # wmllint: ignore
            [/floating_text]

            {CLEAR_VARIABLE temp_PHYSICAL_ENDURANCE_restore_hp}
        [/then]
    [/if]
[/event]
[+abilities]
    # wmlxgettext: [/abilities]
#enddef
# wmllint: unbalanced-off

#define ABILITY_DEMOLITION_TEXT_ONLY
    [dummy]
        id=demolition
        name= _ "demolition"
        description= _ "Demolition:
On death, units with this ability destroy all adjacent hexes and units, and the hex they are standing on."
    [/dummy]
#enddef

# Macro used to implement ABILITY_DEMOLITION_AUXILIARY_EVENT
# and some scenario-specific events.
#
# NOTE: if _ADDITIONAL_LOCATION_FILTER contains terrain=, it must be under an
# [and], [or], or [not] block; otherwise, it will cause problems.
#define ABILITY_DEMOLITION_AUXILIARY_EVENT_DESTRUCTION_IMPLEMENTATION _X _Y _ADDITIONAL_LOCATION_FILTER
    [color_adjust]
        red,green,blue=300,300,300
    [/color_adjust]

    [remove_terrain_overlays]
        x={_X}
        y={_Y}
        radius=1
        {_ADDITIONAL_LOCATION_FILTER}
    [/remove_terrain_overlays]

    [terrain]
        x={_X}
        y={_Y}
        radius=1
        [and]
            terrain=A*,C*,D*,G*,K*,R*,U*
        [/and]
        {_ADDITIONAL_LOCATION_FILTER}
        terrain=Re^Es
    [/terrain]

    [harm_unit]
        [filter]
            [filter_location]
                [filter_adjacent_location]
                    x={_X}
                    y={_Y}
                [/filter_adjacent_location]
            [/filter_location]
        [/filter]

        # No harm source unit or weapon given here, on purpose.

        delay=0
        amount=$this_unit.hitpoints
        # No animations played at this point, since they'd delay the sequence too much
        # in the worst case (six adjacent units)
        animate=no
        kill=no
        fire_event=yes
    [/harm_unit]

    {QUAKE "explosion-big.ogg"}

    [redraw][/redraw] # update terrain display

    [color_adjust]
        red,green,blue=0,0,0
    [/color_adjust]

    # Kill all adjacent units that don't have the demolition ability first;
    # we need to take care of those in a separate step to prevent causing
    # an event loop.

    [kill]
        [filter_location]
            [filter_adjacent_location]
                x={_X}
                y={_Y}
            [/filter_adjacent_location]
        [/filter_location]
        [not]
            ability=demolition
        [/not]
        [not]
            # Shapeshifters are handled by scenario-specific
            # events where they appear, and it might not be
            # a good idea for those to fire at this point.
            [filter_wml]
                [variables]
                    is_shapeshifter=yes
                [/variables]
            [/filter_wml]
        [/not]
        [secondary_unit]
            # the demolition unit killed them
            x={_X}
            y={_Y}
        [/secondary_unit]
        animate=yes
        fire_event=yes
    [/kill]

    # Remove this source unit so the target units with demolition don't
    # trigger its death again.

    [kill]
        x={_X}
        y={_Y}
        animate=no
        fire_event=no
    [/kill]

    # Take care of any remaining adjacent units with demolition.

    [kill]
        [filter_location] # SLF, since there's no unit at (_X, _Y) anymore.
            [filter_adjacent_location]
                x={_X}
                y={_Y}
            [/filter_adjacent_location]
        [/filter_location]
        ability=demolition
        # No secondary unit, but we shouldn't need one in this case.
        animate=yes
        fire_event=yes
    [/kill]
#enddef

#define ABILITY_DEMOLITION_AUXILIARY_EVENT
    [event]
        id=ability_demolition_die
        name=die
        first_time_only=no
        [filter]
            ability=demolition
        [/filter]

        {ABILITY_DEMOLITION_AUXILIARY_EVENT_DESTRUCTION_IMPLEMENTATION $x1 $y1 ()}
    [/event]
#enddef

# wmllint: unbalanced-on
#define ABILITY_DEMOLITION
    {ABILITY_DEMOLITION_TEXT_ONLY}
    # wmlxgettext: [abilities]
[/abilities]

{ABILITY_DEMOLITION_AUXILIARY_EVENT}

[+abilities]
    # wmlxgettext: [/abilities]
#enddef
# wmllint: unbalanced-off

# Following two specials close the [specials] tag and open it later to
# insert a weapon _weight value, eliminating the need to specify it manually
# within the unit's WML file. Therefore, they are intentionally unbalanced WML

# wmllint: match {WEAPON_SPECIAL_ATTACK_ONLY} with {SPECIAL_NOTES_ATTACK_ONLY}
# wmllint: unbalanced-on
#define WEAPON_SPECIAL_ATTACK_ONLY
    [damage]
        id=attack_only
        name= _ "attack only"
        name_inactive= _ "attack only"
        description= _ "Attack Only:
This weapon will never be used on defense."
        description_inactive= _ "Attack Only:
This weapon will never be used on defense."
        multiply=0
        active_on=defense
    [/damage]
# wmlindent: start ignoring
# wmlxgettext: [specials]
    [/specials]
    defense_weight=0
    [+specials]
# wmlxgettext: [/specials]
# wmlindent: stop ignoring
#enddef

# wmllint: match {WEAPON_SPECIAL_DEFEND_ONLY} with {SPECIAL_NOTES_DEFEND_ONLY}
#define WEAPON_SPECIAL_DEFEND_ONLY
    [damage]
        id=attack_only
        name= _ "defend only"
        name_inactive= _ "defend only"
        description= _ "Defend Only:
This weapon will only be available for defense."
        description_inactive= _ "Defend Only:
This weapon will only be available for defense."
        multiply=0
        active_on=offense
    [/damage]
# wmlindent: start ignoring
# wmlxgettext: [specials]
    [/specials]
    attack_weight=0
    [+specials]
# wmlxgettext: [/specials]
# wmlindent: stop ignoring
#enddef
# wmllint: unbalanced-off

#define WEAPON_SPECIAL_ALWAYS_HITS
    [chance_to_hit]
        id=always_hits
        name= _ "always hits"
        description= _ "Always Hits:
This attack always has a 100% chance to hit regardless of the defensive ability of the unit being attacked."
        value=100
        cumulative=no
    [/chance_to_hit]
#enddef

#
# The code for the Stun special is based on the UtBS implementation (as of 1.10),
# with various changes to account for AtS-specific concerns.
#

# wmllint: unbalanced-on
#define WEAPON_SPECIAL_STUN
    [dummy]
        id=stun
        name= _ "stun"
        description= _ "Stun:
This attack puts enormous pressure on the opponent, disrupting its zone of control if a hit is landed. Not active on defense."
    [/dummy]
    # wmlindent: start ignoring
    # wmlxgettext: [specials]
[/specials]
# wmlxgettext: [attack]
[/attack]
# wmlindent: stop ignoring
    [event]
        id=weapon_special_stun_attacker_hits
        name=attacker hits
        first_time_only=no
        [filter_attack]
            special=stun
        [/filter_attack]
        [filter_second]
            [not]
                level=0
                [or]
                    [filter_wml]
                        [status]
                            stunned=yes
                        [/status]
                    [/filter_wml]
                [/or]
            [/not]
        [/filter_second]

        [if]
            {VARIABLE_LEXICAL_EQUALS second_unit.gender female}
            [then]
                {VARIABLE temp_STUN_label _"female^stunned"}
            [/then]
            [else]
                {VARIABLE temp_STUN_label _"stunned"}
            [/else]
        [/if]

        [set_variables]
            name=second_unit.variables
            mode=merge
            [value]
                #
                # .ellipse and .zoc won't be reverted by the object's removal,
                # so that needs to be handled manually.
                #
                [stun_previous_state]
                    ellipse=$second_unit.ellipse
                    zoc=$second_unit.zoc
                [/stun_previous_state]
            [/value]
        [/set_variables]

        {VARIABLE second_unit.status.stunned yes}

        [unstore_unit]
            find_vacant=no
            variable=second_unit
            text=$temp_STUN_label
            red,green,blue=196,196,128
        [/unstore_unit]

        [object]
            silent=yes
            id=stun_effect_set
            duration=level
            [filter]
                x,y=$x2,$y2
            [/filter]
            [effect]
                apply_to=image_mod
                add="CS(50,50,0)"
            [/effect]
            [effect]
                apply_to=ellipse
                ellipse="misc/ellipse-nozoc"
            [/effect]
            [effect]
                apply_to=zoc
                value=no
            [/effect]
        [/object]

        {CLEAR_VARIABLE temp_STUN_label}
    [/event]
    [event]
        id=weapon_special_stun_turn_refresh
        name=turn refresh
        first_time_only=no

        [store_unit]
            [filter]
                side=$side_number
                [filter_wml]
                    [status]
                        stunned=yes
                    [/status]
                [/filter_wml]
            [/filter]
            variable=temp_STUN_restore_units_store
        [/store_unit]

        {FOREACH temp_STUN_restore_units_store temp_STUN_k}
            [set_variables]
                name="temp_STUN_restore_units_store[$temp_STUN_k]"
                mode=merge
                [value]
                    # FIXME: if the unit advanced in the meantime and the new unit type's
                    # ellipse and zoc don't match the backed up state, we're fucked.
                    ellipse=$temp_STUN_restore_units_store[$temp_STUN_k].variables.stun_previous_state.ellipse
                    zoc=$temp_STUN_restore_units_store[$temp_STUN_k].variables.stun_previous_state.zoc
                [/value]
            [/set_variables]

            {CLEAR_VARIABLE temp_STUN_restore_units_store[$temp_STUN_k].status.stunned}
            {CLEAR_VARIABLE temp_STUN_restore_units_store[$temp_STUN_k].variables.stun_previous_state}

            {FOREACH temp_STUN_restore_units_store[$temp_STUN_k].modifications.object temp_STUN_j}
                [if]
                    {VARIABLE_LEXICAL_EQUALS temp_STUN_restore_units_store[$temp_STUN_k].modifications.object[$temp_STUN_j].id stun_effect_set}
                    [then]
                        {CLEAR_VARIABLE temp_STUN_restore_units_store[$temp_STUN_k].modifications.object[$temp_STUN_j]}
                        # break out of the loop
                        {VARIABLE temp_STUN_j $temp_STUN_restore_units_store[$temp_STUN_k].modifications.object.length}
                    [/then]
                [/if]
            {NEXT temp_STUN_j}

            [unstore_unit]
                find_vacant=no
                variable="temp_STUN_restore_units_store[$temp_STUN_k]"
            [/unstore_unit]
        {NEXT temp_STUN_k}

        {CLEAR_VARIABLE temp_STUN_restore_units_store}
    [/event]
# wmlindent: start ignoring
[+attack]
    [+specials]
# wmlindent: stop ignoring
#enddef
# wmllint: unbalanced-off

# kate: indent-mode normal; encoding utf-8; space-indent on;
